/*_____________________________________________________________________________________________________________________
Assignment: Assignment 2
Module:
Author: Radhika Feron & JB
Date: 05/05/2017
Description:
This C language program will implement a basic electronic keyboard using the C8051F120 microcontroller together with 
the Peripheral Interface Board NH10020. The basic concept is to use the Peripheral Interface Board pushbuttons as keys 
where each press of a key will generate a corresponding audio frequency as per the piano frequency scale. Each of 
the required audio frequencies are generated by outputting a square wave of the required frequency to Digital to Analog 
converter 0 on the C8051F120 (DAC0). Volume can be easily controlled by changing the voltage level of the logic 1 of the square wave.  

Innovation: The user can choose to select sine wave mode to output a sine wave to the DAC or a square wave.
The LCD screen will display the note being played, the volume level selected and the wave mode selected, and the authors' names.
The user can select demo mode where the 'keyboard' will play London Bridge and light up the LEDs corresponding to the notes being played.
The user can also select octave mode where the notes are one octave up

Select Demo mode with PB4	(LED4 lights up if selected)
Select Octave mode with PB5 (LED2 lights up if selected)
Select wave mode with PB3 (LED3 lights up if sine wave mode selected, off if square wave mode selected - also shown on LCD)

_____________________________________________________________________________________________________________________*/
#include <compiler_defs.h>
#include <C8051F120_defs.h>  // SFR declarations
#include "Assign_2.h"
int Sound_bit = 0x00;	//In square wave mode, sound_bit selects whether the wave is high or low at that point in time. 
code int high_square[] = { 0xE8,0xEB,0xED,0xEE,0xF0,0xF2,0xF3,0xEA,0xEC,0xED,0xEF,0xF1,0xF3,0xF3 }; 	//integer array stored in code memory containing the higher nibble timer reload values needed for the square wave
code int low_square[] = { 0xF0,0x71,0xB6,0xB8,0x97,0x45,0xC4,0x2C,0x94,0xB6,0xAD,0x70,0x0D,0xC4 }; 	//integer array stored in code memory containing the lower nibble timer reload values needed for the square wave
code int high_octave4[] = { 0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xF9,0xF5,0xF6,0xF6,0xF7,0xF8,0xF9,0xF9 }; //integer array stored in code memory containing the higher nibble timer reload values needed for the square wave, an octave higher than the previous array
code int low_octave4[] = { 0x70,0xB5,0xD0,0x59,0x4A,0x23,0xE0,0x14,0x47,0xD0,0xD9,0xBA,0x82,0xE0 };	//integer array stored in code memory containing the lower nibble timer reload values needed for the square wave, an octave higher than the previous array
code int high_sine[] = { 0xFE,0xFE,0xFE,0xFE,0xFF,0xFF,0xFF,0xFE,0xFE,0xFE,0xFE,0xFF,0xFF,0xFF };	 //integer array stored in code memory containing the higher nibble timer reload values needed for the sine wave
code int low_sine[] = { 0x90,0xB8,0xDB,0xEB,0x0A,0x24,0x3C,0xA3,0xC9,0xDB,0xFB,0x17,0x31,0x3C };	 //integer array stored in code memory containing the lower nibble timer reload values needed for the sine wave
int octave_mode = 0;		//if octave_mode=0 the keyboard plays the normal octave, if =1 it plays the notes one octave up
int high_sound = 0x00; 		// when a button is pressed, the higher bit for the timer reload value of that specific frequency will be stored here. 
int low_sound = 0x00;		// when a button is pressed, the lower bit for the timer reload value of that specific frequency will be stored here. 
int temp_cache_high = 0x00; // high_sound is saved here after the timer has been updated. If two notes are then played at once, the first one would have been saved here. This is then moved to cache_high.
int temp_cache_low = 0x00;	// low_sound is saved here after the timer has been updated. If two notes are then played at once, the first one would have been saved here. This is then moved to cache_high.
int cache_high = 0x00;		// the higher bit of the button frequency will be stored here. Will only change if there are no other buttons being pressed. 
int cache_low = 0x00; 		// the lower bit of the button frequency will be stored here. Will only change if there are no other buttons being pressed. 
int save_P1 = 0x00; 		// copy of pushbuttons. Used to detect a change in the pushbuttons, if such a change is detected the timer reload / frequency is updated.
int key_number = 0;			// used to identify which key is being played. 
int check3 = 0;		 		// checks if multiple notes are being played at once. If so, this is set to 1 to signal that the button pressed first must be played. 
code int volume[] = { 0x000,0x111,0x222,0x333,0x444,0x555,0x666,0x777,0x888,0x999,0xAAA,0xBBB,0xCCC,0xDDD,0xEEE,0xFFF }; //integer array stored in code memory containing the amplitude DAC0 values to change the volume
code int volume_higher[] = { 0x00,0x80,0x40,0xC0,0x20,0xA0,0x60,0xE0,0x10,0x90,0x50,0xD0,0x30,0xB0,0x70,0xF0 }; //array containing the values needed to light up the LED to signify the volume level chosen
int volume_level = 7; 		//default volume level of 7 (out of 16 levels)
int i = 0; 					//variable used to generate a 500ms timer 2 to flash LED1 at 1Hz
bit LCD_delay; 				// used to signal that timer 3 has overflowed and that 1ms has passed since last overflow. Set to 1 when overflowed, otherwise set to 0. 
code int joshuaradhika[] = { 0xD0,0xD4,0xDA,0xD6,0xDF,0xD7,0xD3,0xD6,0xD8,0xD7,0xD5,0xD6,0xD1,0xD2,0xD0,0xD4,0xD2,0xD6,0xD5,0xD7,0xD6,0xD6,0xD5,0xD7,0xD2,0xD6,0xDC,0xD6,0xD5,0xD7,0xD9,0xD2,0xD0,0xD2,0xD6,0xD2,0xD0,0xD5,0xD2,0xD6,0xD1,0xD6,0xD4,0xD6,0xD8,0xD6,0xD9,0xD6,0xDB,0xD6,0xD1,0xD2,0xD0,0xD4,0xD6,0xD6,0xD5,0xD7,0xD2,0xD6,0xDF,0xD6,0xDE,0xD2,0xD0 }; // list of hex codes to display “Joshua Beverley & Radhika Feron” on the LCD display. Every character is represented by two bytes (hex numbers), the higher byte listed first. 
code int joshuaradhikahalf[] = { 0xD0,0xD4,0xDA,0xD6,0xDF,0xD7,0xD3,0xD6,0xD8,0xD7,0xD5,0xD6,0xD1,0xD2,0xD0,0xD2,0xD6,0xD2,0xD0,0xD5,0xD2,0xD6,0xD1,0xD6,0xD4,0xD6,0xD8,0xD6,0xD9,0xD6,0xDB,0xD6,0xD1 }; // list of hex codes used to display “Joshua & Radhika” on the LCD display. Every character is represented by two bytes (hex numbers), the higher byte listed first. 
int volume_save = 7; 		// copy of volume_level. Used to detect a change in volume_level, if such a change is detected the LCD display will be updated. 
bit wave_bit = 0; 			//if wave_bit=0 it is in square wave mode, if =1 it is in sine wave mode
bit save_wave = 0; 			// copy of wave_bit. Used to detect a change in the value of wave_bit, if such a change is detected the LCD display is updated. 
code int sine_wave[] = { 2048,2448,2832,3186,3496,3751,3940,4057,4095,4057,3940,3751,3496,3186,2832,2448,2048,1648,1264,910,600,345,156,39,0,39,156,345,600,910,1264,1648 }; //values to be put into DAC0 as timer 2 overflows to generate a sine wave
int sine_position = 0; 		//initial position in the sine wave array
code int demo_high[] = { 0xF0,0xF2,0xF0,0xEE,0xED,0xEE,0xF0,0xF0,0xEB,0xED,0xEE,0xEE,0xED,0xEE,0xF0,0xF0,0xF0,0xF2,0xF0,0xEE,0xED,0xEE,0xF0,0xF0,0xEB,0xEB,0xF0,0xF0,0xED,0xE8,0xE8,0xE8 }; // the higher bits of the demo song “London Bridge”, copied to the DAC to play the required frequency. 
code int demo_low[] = { 0x82,0x30,0x82,0x9D,0x98,0x9D,0x82,0x82,0x4E,0x98,0x9D,0x9D,0x98,0x9D,0x82,0x82,0x82,0x30,0x82,0x9D,0x98,0x9D,0x82,0x82,0x4E,0x4E,0x82,0x82,0x98,0xC0,0xC0,0xC0 }; // the lower bits of the demo song “London Bridge”, copied to the DAC to play the required frequency. 
code int demo_LED[] = { 6,7,6,5,4,5,6,6,3,4,5,5,4,5,6,6,6,7,6,5,4,5,6,6,3,3,6,6,4,2,2,2 }; // used to light up the corresponding notes on the LEDs while “London Bridge” is being played. 
bit demo_bit = 0; 			//=0 if demo mode is not selected. =1 if demo mode is selected
bit endsong = 0; 			// the notes of London Bridge are played at a note per 500ms (or 120bpm). This is used to signal that timer 4 has overflowed and that 500ms has passed since last overflow, so the next note needs to be played. 
unsigned char SFRPAGE_SAVE;  //when the SFR page needs to be changed, the previous page will be saved into this variable

/*--------------------------------------------------------------------------------------------------------------------
Function:  Main
Description:  Main routine
--------------------------------------------------------------------------------------------------------------------*/
void main(void)
{
	General_Init(); //calls the general initialisation function to initialise watchdog timer, ports, cross bar etc
	Timer2_Init();  //calls the timer 2 initialisation function
	Voltage_Reference_Init(); //calls the voltage reference initialisation function
	Interrupts_Init();  //calls the interrupt initialisation function
	Display_Joshua_Radhika();  //calls the function that displays “Joshua Beverley & Radhika Feron” upon startup. 
	while (1)
	{
		if (demo_bit == 0)  //if the demo bit equals 0 (demo mode has not been selected)
		{
			if ((P1 != save_P1) | (check3 == 1)) //If the pushbuttons have been changed (one has been pressed or released), update timer 2 with correct reload values (frequencies) if required. 
			{
				if (((!PB2 & !PB3) | (!PB2 & !PB4) | (!PB2 & !PB5) | (!PB2 & !PB6) | (!PB2 & !PB7) | (!PB2 & !PB8) | (!PB3 & !PB4) | (!PB3 & !PB5) | (!PB3 & !PB6) | (!PB3 & !PB7) | (!PB3 & !PB8) | (!PB4 & !PB5) | (!PB4 & !PB6) | (!PB4 & !PB7) | (!PB4 & !PB8) | (!PB5 & !PB6) | (!PB5 & !PB7) | (!PB5 & !PB8) | (!PB6 & !PB7) | (!PB6 & !PB8) | (!PB7 & !PB8)) & (check3 == 0))  //If two or more buttons have been pressed, this if statement is entered to ensure the note that was played first is the one that sounds. If the check3 flag has been set to 1 (more below), this won’t be entered and program will update the timer with the correct reload values (frequencies). 
				{
					if (((key_number == 1) & PB2) | ((key_number == 2) & (PB1 & PB2)) | ((key_number == 3) & PB3) | ((key_number == 4) & (PB1 & PB3)) | ((key_number == 5 | key_number == 6) & PB4) | ((key_number == 7) & PB5) | ((key_number == 8) & (PB1 & PB5)) | ((key_number == 9) & PB6) | ((key_number == 10) & (PB1 & PB6)) | ((key_number == 11) & PB7) | ((key_number == 12) & (PB1 & PB7)) | ((key_number == 13 | key_number == 14) & PB8))  //This checks that the note sounding is currently being played. If it isn’t, the flag check3 will be set to 1, and this if statement won’t be entered next iteration. Instead, the program will move to the statement updating the timer with the lowest note currently being pressed. 
					{
						check3 = 1; // Set check3 to 1 so that the if statement won’t be entered next loop. 
						key_number = 0; // Reset the key number. 
					}
					else
					{
						check3 = 0;  // If the above isn’t the case and the note sounding is being pressed, reset the check flag. 
					}
					cache_high = temp_cache_high;  // Use the value stored in temp_cache_high to reload the timer with, as it was the note played first. 
					cache_low = temp_cache_low; // Use the value stored in temp_cache_low to reload the timer with, as it was the note played first. 
				}
				else if (!PB1) //if button 1 is pressed (the sharp notes will be played)
				{
					if (!PB2) //if button 2 is pressed (=0)
					{
						if (wave_bit == 1) //if the wave_bit equals 1, ie, if sine wave mode has been selected
						{
							high_sound = high_sine[7]; //send the 8th value of the high_sine array to high_sound for the desired sine wave frequency
							low_sound = low_sine[7]; //send the 8th value of the low_sine array to low_sound for the desired sine wave frequency
							key_number = 2;   //update key_number with the number representing C#
							Display_Note(); //calls function to display the note played on the LCD specified by key_number
						}
						else if (octave_mode == 0)		//if octave_mode=0 (octave mode has not been selected, play normal notes)
						{
							high_sound = high_square[7]; //send the 8th value of the high_square array to high_sound for the desired square wave frequency
							low_sound = low_square[7]; //send the 8th value of the low_square array to low_sound for the desired square wave frequency
							key_number = 2;   //update key_number with the number representing C#
							Display_Note(); //calls function to display the note played on the LCD specified by key_number
						}
						else 		//if octave_mode=1 (octave mode has been selected, play notes one octave up)
						{
							high_sound = high_octave4[7]; //send the 8th value of the high_square array to high_sound for the desired square wave frequency
							low_sound = low_octave4[7]; //send the 8th value of the low_square array to low_sound for the desired square wave frequency
							key_number = 2;   //update key_number with the number representing C#
							Display_Note(); //calls function to display the note played on the LCD specified by key_number	
						}
					}
					else if (!PB3) //if button 3 is pressed (=0)
					{
						if (wave_bit == 1) //if the wave_bit equals 1, ie, if sine wave mode has been selected.
						{
							high_sound = high_sine[8]; //send the 9th value of the high_sine array to high_sound for the desired sine wave frequency
							low_sound = low_sine[8]; //send the 9th value of the low_sine array to low_sound for the desired sine wave frequency
							key_number = 4;  //update key_number with the number representing D#
							Display_Note(); //calls function to display the note played on the LCD specified by key_number
						}
						else if (octave_mode == 0)		//if octave_mode=0 (octave mode has not been selected, play normal notes)
						{
							high_sound = high_square[8]; //send the 9th value of the high_square array to high_sound for the desired square wave frequency
							low_sound = low_square[8]; //send the 9th value of the low_square array to low_sound for the desired square wave frequency
							key_number = 4;    //update key_number with the number representing C#
							Display_Note(); //calls function to display the note played on the LCD specified by key_number
						}
						else		//if octave_mode=1 (octave mode has been selected, play notes one octave up)
						{
							high_sound = high_octave4[8]; //send the 9th value of the high_square array to high_sound for the desired square wave frequency
							low_sound = low_octave4[8]; //send the 9th value of the low_square array to low_sound for the desired square wave frequency
							key_number = 4;    //update key_number with the number representing C#
							Display_Note(); //calls function to display the note played on the LCD specified by key_number
						}
					}  
					else if (!PB4) //if button 4 is pressed (=0)
					{
						if (wave_bit == 1) { //if the wave_bit equals 1, ie, if sine wave mode has been selected.
							high_sound = high_sine[9]; //send the 10th value of the high_sine array to high_sound for the desired sine wave frequency
							low_sound = low_sine[9]; //send the 10th value of the low_sine array to low_sound for the desired sine wave frequency
							key_number = 6;   //update key_number with the number representing E
							Display_Note(); //calls function to display the note played on the LCD specified by key_number
						}
						else if (octave_mode == 0)		//if octave_mode=0 (octave mode has not been selected, play normal notes)
						{
							high_sound = high_square[9]; //send the 10th value of the high_square array to high_sound for the desired square wave frequency
							low_sound = low_square[9]; //send the 10th value of the low_square array to low_sound for the desired square wave frequency
							key_number = 6;   //update key_number with the number representing E
							Display_Note(); //calls function to display the note played on the LCD specified by key_number
						}
						else		//if octave_mode=1 (octave mode has been selected, play notes one octave up)
						{
							high_sound = high_octave4[9]; //send the 10th value of the high_square array to high_sound for the desired square wave frequency
							low_sound = low_octave4[9]; //send the 10th value of the low_square array to low_sound for the desired square wave frequency
							key_number = 6;   //update key_number with the number representing E
							Display_Note(); //calls function to display the note played on the LCD specified by key_number
						}
					}
					else if (!PB5) //if button 5 is pressed (=0)
					{
						if (wave_bit == 1) { //if the wave_bit equals 1, ie, if sine wave mode has been selected.
							high_sound = high_sine[10]; //send the 11th value of the high_sine array to high_sound for the desired sine wave frequency
							low_sound = low_sine[10]; //send the 11th value of the low_sine array to low_sound for the desired sine wave frequency
							key_number = 8;   //update key_number with the number representing F#
							Display_Note(); //calls function to display the note played on the LCD specified by key_number
						}
						else if (octave_mode == 0)		//if octave_mode=0 (octave mode has not been selected, play normal notes)
						{
							high_sound = high_square[10]; //send the 11th value of the high_square array to high_sound for the desired square wave frequency
							low_sound = low_square[10]; //send the 11th value of the low_square array to low_sound for the desired square wave frequency
							key_number = 8;   //update key_number with the number representing F#
							Display_Note(); //calls function to display the note played on the LCD specified by the key_number
						}
						else 		//if octave_mode=1 (octave mode has been selected, play notes one octave up)
						{
							high_sound = high_octave4[10]; //send the 11th value of the high_square array to high_sound for the desired square wave frequency
							low_sound = low_octave4[10]; //send the 11th value of the low_square array to low_sound for the desired square wave frequency
							key_number = 8;   //update key_number with the number representing F#
							Display_Note(); //calls function to display the note played on the LCD specified by the key_number
						}
					}
					else if (!PB6) //if button 6 is pressed (=0)
					{
						if (wave_bit == 1) { //if the wave_bit equals 1, ie, if sine wave mode has been selected.
							high_sound = high_sine[11]; //send the 12th value of the high_sine array to high_sound for the desired sine wave frequency
							low_sound = low_sine[11]; //send the 12th value of the low_sine array to low_sound for the desired sine wave frequency
							key_number = 10;  //update key_number with the number representing G#
							Display_Note(); //calls function to display the note played on the LCD specified by key_number
						}
						else if (octave_mode == 0) {		//if octave_mode=0 (octave mode has not been selected, play normal notes)
							high_sound = high_square[11]; //send the 12th value of the high_square array to high_sound for the desired square wave frequency
							low_sound = low_square[11]; //send the 12th value of the low_square array to low_sound for the desired square wave frequency
							key_number = 10;  //update key_number with the number representing G#
							Display_Note(); //calls function to display the note played on the LCD specified by key_number
						}
						else {		//if octave_mode=1 (octave mode has been selected, play notes one octave up)
							high_sound = high_octave4[11]; //send the 12th value of the high_square array to high_sound for the desired square wave frequency
							low_sound = low_octave4[11]; //send the 12th value of the low_square array to low_sound for the desired square wave frequency
							key_number = 10;  //update key_number with the number representing G#
							Display_Note(); //calls function to display the note played on the LCD specified by key_number
						}
					}
					else if (!PB7) //if button 7 is pressed (=0)
					{
						if (wave_bit == 1) { //if the wave_bit equals 1, ie, if sine wave mode has been selected.
							high_sound = high_sine[12]; //send the 13th value of the high_sine array to high_sound for the desired sine wave frequency
							low_sound = low_sine[12]; //send the 13th value of the low_sine array to low_sound for the desired sine wave frequency
							key_number = 12;  //update key_number with the number representing A#
							Display_Note(); //calls function to display the note played on the LCD specified by the key number
						}
						else if (octave_mode == 0) {		//if octave_mode=0 (octave mode has not been selected, play normal notes)
							high_sound = high_square[12]; //send the 13th value of the high_square array to high_sound for the desired square wave frequency
							low_sound = low_square[12]; //send the 13th value of the low_square array to low_sound for the desired square wave frequency
							key_number = 12;  //update key_number with the number representing A#
							Display_Note(); //calls function to display the note played on the LCD specified by key_number
						}
						else {		//if octave_mode=1 (octave mode has been selected, play notes one octave up)
							high_sound = high_octave4[12]; //send the 13th value of the high_square array to high_sound for the desired square wave frequency
							low_sound = low_octave4[12]; //send the 13th value of the low_square array to low_sound for the desired square wave frequency
							key_number = 12;  //update key_number with the number representing A#
							Display_Note(); //calls function to display the note played on the LCD specified by key_number
						}
					}
					else if (!PB8) //if button 8 is pressed (=0)
					{
						if (wave_bit == 1) { //if the wave_bit equals 1, ie, if sine wave mode has been selected.
							high_sound = high_sine[13]; //send the 14th value of the high_sine array to high_sound for the desired sine wave frequency
							low_sound = low_sine[13]; //send the 14th value of the low_sine array to low_sound for the desired sine wave frequency
							key_number = 14;  //update key_number with the number representing B
							Display_Note(); //calls function to display the note played on the LCD specified by key_number
						}
						else if (octave_mode == 0) {		//if octave_mode=0 (octave mode has not been selected, play normal notes)
							high_sound = high_square[13]; //send the 14th value of the high_square array to high_sound for the desired square wave frequency
							low_sound = low_square[13]; //send the 14th value of the low_square array to low_sound for the desired square wave frequency
							key_number = 14;  //update key_number with the number representing B
							Display_Note(); //calls function to display the note played on the LCD specified by key_number
						}	
						else {		//if octave_mode=1 (octave mode has been selected, play notes one octave up)
							high_sound = high_octave4[13]; //send the 14th value of the high_square array to high_sound for the desired square wave frequency
							low_sound = low_octave4[13]; //send the 14th value of the low_square array to low_sound for the desired square wave frequency
							key_number = 14;  //update key_number with the number representing B
							Display_Note(); //calls function to display the note played on the LCD specified by key_number
						}
					}
					else
					{
						DAC_Deinit(); //call the DAC deinitialisation function to switch the dac off
					}
					check3 = 0;	// If the above isn’t the case and the note sounding is being pressed, reset the check flag. 
				}
				else
				{
					if (!PB2) //if button 2 is pressed (=0)
					{
						if (wave_bit == 1) { //if the wave_bit equals 1, ie, if sine wave mode has been selected.
							high_sound = high_sine[0]; //send the 1st value of the high_sine array to high_sound for the desired sine wave frequency
							low_sound = low_sine[0]; //send the 1st value of the low_sine array to low_sound for the desired sine wave frequency
							key_number = 1;   //update key_number with the number representing C
							Display_Note(); //calls function to display the note played on the LCD specified by key_number
						}
						else if (octave_mode == 0) {		//if octave_mode=0 (octave mode has not been selected, play normal notes)
							high_sound = high_square[0]; //send the 1st value of the high_square array to high_sound for the desired square wave frequency
							low_sound = low_square[0]; //send the 1st value of the low_square array to low_sound for the desired square wave frequency
							key_number = 1;   //update key_number with the number representing C
							Display_Note(); //calls function to display the note played on the LCD specified by key_number
						}
						else {		//if octave_mode=1 (octave mode has been selected, play notes one octave up)
							high_sound = high_octave4[0]; //send the 1st value of the high_square array to high_sound for the desired square wave frequency
							low_sound = low_octave4[0]; //send the 1st value of the low_square array to low_sound for the desired square wave frequency
							key_number = 1;   //update key_number with the number representing C
							Display_Note(); //calls function to display the note played on the LCD specified by key_number
						}
					}
					else if (!PB3) //if button 3 is pressed (=0)
					{
						if (wave_bit == 1) { //if the wave_bit equals 1, ie, if sine wave mode has been selected.
							high_sound = high_sine[1]; //send the 2nd value of the high_sine array to high_sound for the desired sine wave frequency
							low_sound = low_sine[1]; //send the 2nd value of the low_sine array to low_sound for the desired sine wave frequency
							key_number = 3;  //update key_number with the number representing D
							Display_Note(); //calls function to display the note played on the LCD specified by key_number
						}
						else if (octave_mode == 0) {		//if octave_mode=0 (octave mode has not been selected, play normal notes)
							high_sound = high_square[1]; //send the 2nd value of the high_square array to high_sound for the desired square wave frequency
							low_sound = low_square[1]; //send the 2nd value of the low_square array to low_sound for the desired square wave frequency
							key_number = 3;  //update key_number with the number representing D
							Display_Note(); //calls function to display the note played on the LCD specified by key_number
						}
						else {		//if octave_mode=1 (octave mode has been selected, play notes one octave up)
							high_sound = high_octave4[1]; //send the 2nd value of the high_square array to high_sound for the desired square wave frequency
							low_sound = low_octave4[1]; //send the 2nd value of the low_square array to low_sound for the desired square wave frequency
							key_number = 3;  //update key_number with the number representing D
							Display_Note(); //calls function to display the note played on the LCD specified by key_number
						}
					}
					else if (!PB4) //if button 4 is pressed (=0)
					{
						if (wave_bit == 1) { //if the wave_bit equals 1, ie, if sine wave mode has been selected.
							high_sound = high_sine[2]; //send the 3rd value of the high_sine array to high_sound for the desired sine wave frequency
							low_sound = low_sine[2]; //send the 3rd value of the low_sine array to low_sound for the desired sine wave frequency
							key_number = 5;  //update key_number with the number representing E
							Display_Note(); //calls function to display the note played on the LCD specified by key_number
						}
						else if (octave_mode == 0) {		//if octave_mode=0 (octave mode has not been selected, play normal notes)
							high_sound = high_square[2]; //send the 3rd value of the high_square array to high_sound for the desired square wave frequency
							low_sound = low_square[2]; //send the 3rd value of the low_square array to low_sound for the desired square wave frequency
							key_number = 5;  //update key_number with the number representing E
							Display_Note(); //calls function to display the note played on the LCD specified by key_number
						}
						else {		//if octave_mode=1 (octave mode has been selected, play notes one octave up)
							high_sound = high_octave4[2]; //send the 3rd value of the high_square array to high_sound for the desired square wave frequency
							low_sound = low_octave4[2]; //send the 3rd value of the low_square array to low_sound for the desired square wave frequency
							key_number = 5;  //update key_number with the number representing E
							Display_Note(); //calls function to display the note played on the LCD specified by key_number
						}
					}
					else if (!PB5) //if button 5 is pressed (=0)
					{
						if (wave_bit == 1) { //if the wave_bit equals 1, ie, if sine wave mode has been selected.
							high_sound = high_sine[3]; //send the 4th value of the high_sine array to high_sound for the desired sine wave frequency
							low_sound = low_sine[3]; //send the 4th value of the low_sine array to low_sound for the desired sine wave frequency
							key_number = 7;  //update key_number with the number representing F
							Display_Note(); //calls function to display the note played on the LCD specified by key_number
						}
						else if (octave_mode == 0) {		//if octave_mode=0 (octave mode has not been selected, play normal notes)
							high_sound = high_square[3]; //send the 4th value of the high_square array to high_sound for the desired square wave frequency
							low_sound = low_square[3]; //send the 4th value of the low_square array to low_sound for the desired square wave frequency
							key_number = 7;  //update key_number with the number representing F
							Display_Note(); //calls function to display the note played on the LCD specified by key_number
						}
						else {		//if octave_mode=1 (octave mode has been selected, play notes one octave up)
							high_sound = high_octave4[3]; //send the 4th value of the high_square array to high_sound for the desired square wave frequency
							low_sound = low_octave4[3]; //send the 4th value of the low_square array to low_sound for the desired square wave frequency
							key_number = 7;  //update key_number with the number representing F
							Display_Note(); //calls function to display the note played on the LCD specified by key_number
						}
					}
					else if (!PB6) //if button 6 is pressed (=0)
					{
						if (wave_bit == 1) { //if the wave_bit equals 1, ie, if sine wave mode has been selected.
							high_sound = high_sine[4]; //send the 5th value of the high_sine array to high_sound for the desired sine wave frequency
							low_sound = low_sine[4]; //send the 5th value of the low_sine array to low_sound for the desired sine wave frequency
							key_number = 9;  //update key_number with the number representing G
							Display_Note(); //calls function to display the note played on the LCD specified by key_number
						}
						else if (octave_mode == 0) {		//if octave_mode=0 (octave mode has not been selected, play normal notes)
							high_sound = high_square[4]; //send the 5th value of the high_square array to high_sound for the desired square wave frequency
							low_sound = low_square[4]; //send the 5th value of the low_square array to low_sound for the desired square wave frequency
							key_number = 9;  //update key_number with the number representing G
							Display_Note(); //calls function to display the note played on the LCD specified by key_number
						}
						else {		//if octave_mode=1 (octave mode has been selected, play notes one octave up)
							high_sound = high_octave4[4]; //send the 5th value of the high_square array to high_sound for the desired square wave frequency
							low_sound = low_octave4[4]; //send the 5th value of the low_square array to low_sound for the desired square wave frequency
							key_number = 9;  //update key_number with the number representing G
							Display_Note(); //calls function to display the note played on the LCD specified by key_number
						}
					}
					else if (!PB7) //if button 7 is pressed (=0)
					{
						if (wave_bit == 1) { //if the wave_bit equals 1, ie, if sine wave mode has been selected.
							high_sound = high_sine[5]; //send the 6th value of the high_sine array to high_sound for the desired sine wave frequency
							low_sound = low_sine[5]; //send the 6th value of the low_sine array to low_sound for the desired sine wave frequency
							key_number = 11;  //update key_number with the number representing A
							Display_Note(); //calls function to display the note played on the LCD specified by key_number
						}
						else if (octave_mode == 0) {		//if octave_mode=0 (octave mode has not been selected, play normal notes)
							high_sound = high_square[5]; //send the 6th value of the high_square array to high_sound for the desired square wave frequency
							low_sound = low_square[5]; //send the 6th value of the low_square array to low_sound for the desired square wave frequency
							key_number = 11;  //update key_number with the number representing A
							Display_Note(); //calls function to display the note played on the LCD specified by key_number
						}
						else {		//if octave_mode=1 (octave mode has been selected, play notes one octave up)
							high_sound = high_octave4[5]; //send the 6th value of the high_square array to high_sound for the desired square wave frequency
							low_sound = low_octave4[5]; //send the 6th value of the low_square array to low_sound for the desired square wave frequency
							key_number = 11;  //update key_number with the number representing A
							Display_Note(); //calls function to display the note played on the LCD specified by key_number
						}
					}
					else if (!PB8) //if button 8 is pressed (=0)
					{
						if (wave_bit == 1) { //if the wave_bit equals 1, ie, if sine wave mode has been selected.
							high_sound = high_sine[6]; //send the 7th value of the high_sine array to high_sound for the desired sine wave frequency
							low_sound = low_sine[6]; //send the 7th value of the low_sine array to low_sound for the desired sine wave frequency
							key_number = 13;  //update key_number with the number representing B
							Display_Note(); //calls function to display the note played on the LCD specified by key_number
						}
						else if (octave_mode == 0) {		//if octave_mode=0 (octave mode has not been selected, play normal notes)
							high_sound = high_square[6]; //send the 7th value of the high_square array to high_sound for the desired square wave frequency
							low_sound = low_square[6]; //send the 7th value of the low_square array to low_sound for the desired square wave frequency
							key_number = 13;  //update key_number with the number representing B
							Display_Note(); //calls function to display the note played on the LCD specified by key_number
						}
						else {		//if octave_mode=1 (octave mode has been selected, play notes one octave up)
							high_sound = high_octave4[6]; //send the 7th value of the high_square array to high_sound for the desired square wave frequency
							low_sound = low_octave4[6]; //send the 7th value of the low_square array to low_sound for the desired square wave frequency
							key_number = 13;  //update key_number with the number representing B
							Display_Note(); //calls function to display the note played on the LCD specified by key_number
						}
					}
					else
					{
						DAC_Deinit(); //call the DAC deinitialisation function to switch the dac off
					}
					check3 = 0;	// If the above isn’t the case and the note sounding is being pressed, reset the check flag. 
				}

				cache_high = high_sound;  //Saves the high byte for the desired frequency to the value used for the timer reload. 
				cache_low = low_sound;   //Saves the low byte for the desired frequency to the value used for the timer reload. 
				temp_cache_high = high_sound; //Saves the high byte to temporary storage, used if two notes are pressed at once. 
				temp_cache_low = low_sound;  //Saves the low byte to temporary storage, used if two notes are pressed at once. 

				if (!PB2 | !PB3 | !PB4 | !PB5 | !PB6 | !PB7 | !PB8)  //if any of pushbutton 2-8 is pressed (=0)
				{
					DAC_Init();  //calls the DAC initialisation function
				}
				Timer2_Init(); //calls the timer 2 initialisation function to re-initialise with the new frequencies
				P2 = ~P1;  //lights up the corresponding LED’s when a pushbutton is pressed. 
				save_P1 = P1; //saves the value of P1 so it can be compared to P1 when a change has been made. To save unnecessary processing power, the function will only update frequencies to the timer if a change has been made. 
			}
			else if (!MPB) //if mode pushbutton is pressed (=0)
			{
				LD3 = wave_bit;  //display the wave mode on LED3 by setting LED3 to the wave_bit
				LD2= octave_mode;	//display the octave mode on LED2 by setting LED2 to octave_mode
				Display_Volume();
				while (!MPB) //debounces the pushbutton by checking if the button is still pressed until it is released
				{
				}
				while (MPB) //while the mode pushbutton is not pressed
				{
					Timer4_Init(); //call the timer 4 initialisation function
					volume_save = volume_level;
					save_wave = wave_bit;
					if (!PB1) //if pushbutton 1 is pressed (=0) it will increase the volume level
					{
						while (!PB1) //debounces the pushbutton by checking if the button is still pressed until it is released
						{
						}
						if ((volume_level != 15)) //if the volume level is not 15
						{
							volume_level = volume_level + 1; //increase the volume level by 1
						}
					}
					else if (!PB2) //if pushbutton 2 is pressed (=0) it will decrease the volume level
					{
						while (!PB2) //debounces the pushbutton by checking if the button is still pressed until it is released
						{
						}
						if ((volume_level != 0)) //if the volume level is not 0
						{
							volume_level = volume_level - 1; //decrease the volume level by 1
						}
					}
					else if (!PB3) //if pushbutton 3 is pressed (=0) it will select sine wave or square wave mode
					{
						while (!PB3) //debounces the pushbutton by checking if the button is still pressed until it is released
						{
						}
						if (wave_bit == 1) { //if the wave bit already equals 1
							wave_bit = 0; //let wave bit equal 0
						}
						else { //if the wave bit is equal to 0
							wave_bit = 1; //let the wave bit equal 1
						}
						LD3 = wave_bit; //display the wave bit on the LED to show the selection of sine or square wave mode
					}
					else if (!PB4) //if pushbutton 4 is pressed (=0) it will select demo mode or deselect it
					{
						while (!PB4) //debounces the pushbutton by checking if the button is still pressed until it is released
						{
						}
						if (demo_bit == 1) { //if the demo bit already equals 1
							demo_bit = 0; //let demo bit equal 0
						}
						else { //if the demo bit already equals 0
							demo_bit = 1; //let demo bit equal 1
						}
						LD4 = demo_bit; //display the wave bit on the LED to show where demo mode is selected or not
					}
					else if (!PB5) //if pushbutton 5 is pressed (=0) it will select an octave higher or octave lower
					{
						while (!PB5) //debounces the pushbutton by checking if the button is still pressed until it is released
						{
						}
						if (octave_mode == 1) { //if the octave mode already equals 1
							octave_mode = 0; //let octave mode equal 0
						}
						else { //if the demo bit already equals 0
							octave_mode = 1; //let octave mode equal 1
						}
						LD2 = octave_mode; //display the octave mode on the LED to show where octave mode is selected or not
					}
					//The below if else statements display the volume on the LEDs. A bit reversal is required. 
					if (volume_level % 2 == 1) //For LED8, turn it on if the volume is an odd number. If the remainder when divided by 2 [modulo] is 1, the volume is an odd number. 
						LD8 = 1;
					else      //Else, turn it off. 
						LD8 = 0;
					if (volume_level % 4 == 2 | volume_level % 4 == 3)  //For LED7, turn it on if volume is equal to 2, 3, 6, 7, 10, 11, 14, or 15. Modulo with 4, if the result is 2 or 3, the volume is set to one of these numbers. 
						LD7 = 1;
					else     //Else, turn it off
						LD7 = 0;
					if (volume_level / 4 == 1 | volume_level / 4 == 3)  //For LED6, turn if on if volume is between 5-8 or 12-15. Divide by 4, if the result is truncated to 1 or 3, the volume is set to one of these numbers. 
						LD6 = 1;
					else      //Else, turn it off. 
						LD6 = 0;
					if (volume_level / 8 == 1) //For LED5, turn it on if volume is larger than 8. Divide by 8, the truncated result will be 1 if the volume is larger than 8. 
						LD5 = 1;
					else     //Else, turn it off. 
						LD5 = 0;
					if ((volume_save != volume_level) | (save_wave != wave_bit))
					{
						Display_Volume();
					}
				}
				while (!MPB) //debounces the pushbutton by checking if the button is still pressed until it is released
				{
				}
				TMR4CN = 0x00; //stop timer 4 by sending 0 to the timer 4 control register
				endsong = 0; //ensures the final note from the demo song (if selected) has stopped playing. 
				P2 = 0; //clear P2 (LEDS)
				Display_Joshua_Radhika(); //Display “Joshua Beverley & Radhika Feron” on the LCD screen. 
			}
			else if (PB2 & PB3 & PB4 & PB5 & PB6 & PB7 & PB8) //if pushbutton 2-8 are not pressed (ie =1)
			{
				DAC_Deinit(); //call the DAC_DEinit function to switch the DAC off
			}
		}

		else  //else if demo_bit equals 1 (demo mode has been selected)
		{
			int e = 0;  //initial position in the demo song arrays is zero
			Timer4_Init(); //call Timer 4 initialisation function
			DAC_Init(); //call DAC initialisation function
			for (e = 0;e<31;e++)  //e represents what note the demo song is up to. It will be incremented as the beat of the song progresses. 
			{
				while (endsong == 0) //while the endsong variable hasn’t been set to 1, infinitely loop. The loop will break when timer 4 overflows. 
				{
				}
				cache_high = demo_high[e]; //Set the higher byte reload value for timer 2 to the correct note in the demo_high array. 
				cache_low = demo_low[e]; //Set the lower byte reload value for timer 2 to the correct note in the demo_low array. 
				Timer2_Init();  //calls timer 2 initialisation function to reinitialise the timer with the new frequencies
				endsong = 0;  //resets the timer 4 flag. 
				if (demo_LED[e] == 2) //if the value of demo_LED is 2 at that particular position
				{
					P2 = 0; //clear P2 (LEDs)
					LD2 = 1; //set LED2 to light it up
				}
				else if (demo_LED[e] == 3)  //if the value of demo_LED is 3 at that particular position
				{
					P2 = 0; //clear P2 (LEDs)
					LD3 = 1; //set LED3 to light it up
				}
				else if (demo_LED[e] == 4)  //if the value of demo_LED is 4 at that particular position
				{
					P2 = 0; //clear P2 (LEDs)
					LD4 = 1; //set LED4 to light it up
				}
				else if (demo_LED[e] == 5)  //if the value of demo_LED is 5 at that particular position
				{
					P2 = 0; //clear P2 (LEDs)
					LD5 = 1; //set LED5 to light it up
				}
				else if (demo_LED[e] == 6)  //if the value of demo_LED is 6 at that particular position
				{
					P2 = 0; //clear P2 (LEDs)
					LD6 = 1; //set LED6 to light it up
				}
				else if (demo_LED[e] == 7)  //if the value of demo_LED is 7 at that particular position
				{
					P2 = 0; //clear P2 (LEDs)
					LD7 = 1; //set LED7 to light it up
				}
				else
				{
					P2 = 0; //clear P2 (LEDs)
				}

			}
			DAC_Deinit();   //calls the DAC de-initialisation function to switch the DAC off
			SFRPAGE_SAVE = SFRPAGE;  // Save Current SFR page
			SFRPAGE = TMR4_PAGE;  //Set SFR page to Timer 4 page
			TMR4CN = 0x00; //stop timer 4 by sending 0 to the timer 4 control register
			P2 = 0; //clear P2 (LEDS)
			demo_bit = 0; //clear demo_bit to deselect demo mode
			SFRPAGE = SFRPAGE_SAVE;  //set SFR page to previously saved page
		}
	}
}

/*--------------------------------------------------------------------------------------------------------------------
Function: Display_Joshua_Radhika

Description: Display “Joshua Beverley & Radhika Feron” upon startup and when entering play state from volume state.


--------------------------------------------------------------------------------------------------------------------*/
void Display_Joshua_Radhika()
{
	int m = 0;    //Variable used for the for loop. 
	LCD_Init();    //Initialise the LCD screen. 
	for (m = 0; m<33; m++)   //16 characters in the first line “Joshua Beverley ” so the for loop needs to repeated 33 times to print all characters. One additional iteration is needed to display the command used to initialise displaying characters on the the LCD screen (0xD0); this is the first hex number in the array. 
	{
		LCD = joshuaradhika[m];  // Selects hex number from the joshuaradhika array to display that corresponding character on the LCD.
		Toggle_E();    //Toggle the E line
	}
	for (m = 0; m<47; m++)   //Change the address so that characters can be displayed on the second line of the LCD. 
	{
		LCD = 0xD0;
		Toggle_E();    //Toggle the E line
	}
	for (m = 32; m<66; m++)  //16 characters in the second line “& Radhika Feron ” so the for loop needs to repeated 32 times to print all characters.
	{
		LCD = joshuaradhika[m];  // Selects hex number from the joshuaradhika array to display that corresponding character on the LCD.
		Toggle_E();    //Toggle the E line
	}
}
/*--------------------------------------------------------------------------------------------------------------------
Function: Display_Note

Description:  Display the key being played on the LCD screen.

--------------------------------------------------------------------------------------------------------------------*/
void Display_Note()
{
	code int NoteDisplayLCD[] = { 0xD3,0xD4,0xD5,0xD6,0xD7,0xD1,0xD2 };  // List of hex codes to display any key name on the LCD display. The second number (0xD4) is the most significant byte for all key names; the other hex numbers are the least significant bytes for the keys C,D,E,F,G,A,B. The # is represented by 0xD2 and 0xD3. Every character is represented by two bytes (hex numbers), the higher byte listed first. This has been defined locally due to space restrictions on global variables. 
	int m = 0;    //Variable used for the for loop. 
	LCD_Init();    //Initialise the LCD screen. 
	LCD = 0xD0;    //Command used to initialise displaying characters on the the LCD screen. 
	Toggle_E();    //Toggle the E line
	for (m = 1; m<33; m++)   //Display “Joshua & Radhika” on the top row of the LCD screen. 16 characters in wave_selection_LCD, so the for loop needs to repeat 32 times to print all characters. 
	{
		LCD = joshuaradhikahalf[m]; // Selects hex number from the joshuaradhikahalf array to display that corresponding character on the LCD.
		Toggle_E();    //Toggle the E line
	}
	for (m = 0; m<24; m++)   //Change the address so that characters can be displayed on the second line of the LCD. 
	{
		LCD = 0xD2;
		Toggle_E();    //Toggle the E line
		LCD = 0xD0;
		Toggle_E();    //Toggle the E line
	}
	LCD = NoteDisplayLCD[1];  //Most significant byte for displaying the letter. 
	Toggle_E();    //Toggle the E line
	LCD = NoteDisplayLCD[((key_number + 1) / 2) - 1];  //Using the key number global variable, select the number from the array corresponding to the key. Byte selected from the array is the least significant byte for displaying the key. 

	Toggle_E();    //Toggle the E line
	if (key_number == 2 | key_number == 4 | key_number == 8 | key_number == 10 | key_number == 12) //If the key number is any of these that require a sharp character (#), display one. 
	{
		LCD = NoteDisplayLCD[6];  //Most significant byte for displaying the #
		Toggle_E();    //Toggle the E line
		LCD = NoteDisplayLCD[0];  //Least significant byte for displaying a #. 
		Toggle_E();    //Toggle the E line
	}
	else //If the key number isn’t any of the #’s, display a space instead. 
	{
		LCD = 0xD2;    //Most significant byte for displaying a space.
		Toggle_E();    //Toggle the E line
		LCD = 0xD0;    //Least significant byte for displaying a space. 
		Toggle_E();    //Toggle the E line
	}
}
/*--------------------------------------------------------------------------------------------------------------------
Function: Display_Volume

Description: When volume mode is selected, the volume level (0-15) is shown on the first line of the LCD.
--------------------------------------------------------------------------------------------------------------------*/
void Display_Volume()
{
	code int volumeword[] = { 0xD5,0xD6,0xD6,0xDF,0xD6,0xDC,0xD7,0xD5,0xD6,0xDD,0xD6,0xD5,0xD3,0xDA,0xD2,0xD0 }; // List of hex codes to display “Volume: ” on the LCD display. Every character is represented by two bytes (hex numbers), the higher byte listed first. This has been defined locally due to space restrictions on global variables. 
	code int volume_LCD[] = { 0xD3,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9 }; // List of hex codes to display any number on the LCD display. The first number (0xD3) is the most significant byte for all numbers, while the next 10 numbers are the least significant bytes for numbers 0-9. Every character is represented by two bytes (hex numbers), the higher byte listed first. This has been defined locally due to space restrictions on global variables. 
	int m = 0;    //Variable used for the for loop. 
	LCD_Init();    //Initialise the LCD screen. 
	LCD = 0xD0;    //Command used to initialise displaying characters on the the LCD screen. 
	Toggle_E();    //Toggle the E line
	for (m = 0; m<16; m++)   //8 characters in wave_selection_LCD, so the for loop needs to repeat 16 times to print all characters. 
	{
		LCD = volumeword[m];  // Selects hex number from the array to display that corresponding character on the LCD.
		Toggle_E();    //Toggle the E line
	}

	LCD = 0xD3;    //Most significant byte for displaying the first number. 
	Toggle_E();    //Toggle the E line
	if (volume_level<10)   //If the volume level is 10 or larger, display a 1 on the LCD. 
	{
		LCD = 0xD0;    //Least significant byte for displaying a 1. 
		Toggle_E();    //Toggle the E line
		LCD = 0xD3;    //Most significant byte for displaying the second number. 
		Toggle_E();    //Toggle the E line
		LCD = volume_LCD[volume_level + 1];  //Select the number from the array corresponding to the volume level. Byte selected from the array is the least significant byte for displaying the second number.
		Toggle_E();    //Toggle the E line
	}
	else      //Else the volume is less than 10, display a 0 on the LCD. 
	{
		LCD = 0xD1;    //Least significant byte for displaying a 0. 
		Toggle_E();    //Toggle the E line
		LCD = 0xD3;    //Most significant byte for displaying the second number. 
		Toggle_E();    //Toggle the E line
		LCD = volume_LCD[volume_level - 9];  //Select the number from the array corresponding to the volume level. Byte selected from the array is the least significant byte for displaying the second number. 
		Toggle_E();    //Toggle the E line
	}
	for (m = 0; m<30; m++)   //Change the address so that characters can be displayed on the second line of the LCD. 
	{
		LCD = 0xD2;
		Toggle_E();    //Toggle the E line
		LCD = 0xD0;
		Toggle_E();    //Toggle the E line
	}
	DispWaveBitLCD();   //On the second line of the LCD, display the wave type (sine/square). 
}
/*--------------------------------------------------------------------------------------------------------------------
Function: DispWaveBitLCD

Description: When volume mode is selected, the type of wave selected (square/sin) is shown on the second line of the LCD.
--------------------------------------------------------------------------------------------------------------------*/
void DispWaveBitLCD()
{
	code int wave_selection_LCD[] = { 0xD5,0xD7,0xD6,0xD1,0xD7,0xD6,0xD6,0xD5,0xD2,0xD0,0xD5,0xD4,0xD7,0xD9,0xD7,0xD0,0xD6,0xD5,0xD3,0xDA,0xD2,0xD0 }; // list of hex codes to display “Wave Type: ” on the LCD display. Every character is represented by two bytes (hex numbers), the higher byte listed first. This has been defined locally due to space restrictions on global variables. 
	int p = 0;     //variable used for the for loop
	for (p = 0;p<22;p++)   //11 characters in wave_selection_LCD, so the for loop needs to repeat 22 times to print all characters. 
	{
		LCD = wave_selection_LCD[p]; // selects hex number from the array to display that corresponding character on the LCD.
		Toggle_E();    // Toggle the E line
	}
	if (wave_bit == 1)   //If a sine wave has been selected, write “sin” on the LCD. 
	{
		int wave_sin_LCD[] = { 0xD7,0xD3,0xD6,0xD9,0xD6,0xDE }; //list of hex codes to display “sin” on the LCD display after “Wave Type: “. This has been defined locally due to space restrictions on global variables. 
		for (p = 0;p<6;p++)   //3 characters in wave_sin_LCD, so the for loop needs to repeat 6 times to print all characters. 
		{
			LCD = wave_sin_LCD[p];  // selects hex number from the array to display that corresponding character on the LCD.
			Toggle_E();    // Toggle the E line
		}
	}
	else     //else, square wave mode has been selected, write “squ” on the LCD. 
	{
		int wave_squ_LCD[] = { 0xD7,0xD3,0xD7,0xD1,0xD7,0xD5 }; //list of hex codes to display “squ” on the LCD display after “Wave Type: “. This has been defined locally due to space restrictions on global variables. 
		for (p = 0;p<6;p++)   //3 characters in wave_squ_LCD, so the for loop needs to repeat 6 times to print all characters. 
		{
			LCD = wave_squ_LCD[p];  // selects hex number from the array to display that corresponding character on the LCD.
			Toggle_E();    // Toggle the E line
		}
	}
}

/*--------------------------------------------------------------------------------------------------------------------
Function:  General_Init
Description:  Initialise ports, watchdog....
--------------------------------------------------------------------------------------------------------------------*/
void General_Init()
{
	WDTCN = 0xde; //turn off watchdog timer
	WDTCN = 0xad;
	SFRPAGE = CONFIG_PAGE; //set SFR page to the configuration page
	P2MDOUT = 0xff;  //P2.[0-7]=outputs

	XBR2 = 0x40; //enable crossbar

}
/*--------------------------------------------------------------------------------------------------------------------
Function:  LCD_Init
Description:  Initialise LCD. Note that the LCD has a 4 bit hardware connection
P3.7 BL => MPB pushbutton on the C8051F120 board.
P3.6 E => Enable
P3.5 R/W => Read/Write line
P3.4 RS => Register Select
P3.3 D7 => Data line
P3.2 D6 => Data line
P3.1 D5 => Data line
P3.0 D4 => Data line
--------------------------------------------------------------------------------------------------------------------*/
void LCD_Init()
{

	LCD = 0x80;
	Xms_Delay(20); // 20ms delay
	LCD = 0x83; // Function Set 
	Toggle_E(); // Toggle the E line
	Xms_Delay(5); // 5ms delay 
	LCD = 0x83; // Function Set 
	Toggle_E(); // Toggle the E line
	Xms_Delay(1); // 1ms delay 
	LCD = 0x83; // Function Set 
	Toggle_E(); // Toggle the E line
	Xms_Delay(1); // 1ms delay 
	LCD = 0x82; // Function Set 
	Toggle_E(); // Toggle the E line
	LCD = 0x82; // Function Set 
	Toggle_E();
	LCD = 0x88; // 2 lines, 5x8 display 
	Toggle_E();
	LCD = 0x80; // Display off 
	Toggle_E();
	LCD = 0x88;
	Toggle_E();
	LCD = 0x80; // Display clear display 
	Toggle_E();
	LCD = 0x81;
	Toggle_E();
	LCD = 0x80; // Cursor increment
	Toggle_E();
	LCD = 0x86;
	Toggle_E();

	LCD = 0x80; // Display on
	Toggle_E();
	LCD = 0x8C;
	Toggle_E();

}
/*--------------------------------------------------------------------------------------------------------------------
Function:  Xms_Delay
Description:  Generates an X ms delay according to the integer number input.
--------------------------------------------------------------------------------------------------------------------*/

void Xms_Delay(int n)
{
	int m = 0;   //variable used for the for loop
	for (m = 0; m < n; m++) //m will increment every 1ms when the timer 3 overflows and is reset. When it reaches n, the specified number of milliseconds, the for loop will break. 
	{
		Timer3_Init();   //initialise timer 3. 
		while (LCD_delay == 0) //while the LCD_delay variable hasn’t been set to 1, infinitely loop. The loop will break when timer 3 overflows. 
		{
		}
		LCD_delay = 0;  //reset the flag to 0 for next use
		TMR3CN = 0x00; //turns the timer off, will be re initialised next iteration of the for loop.
	}
}
/*--------------------------------------------------------------------------------------------------------------------
Function:  Toggle_E
Description:  Toggle the E line for the LCD. There is a 1ms wait between toggles.
--------------------------------------------------------------------------------------------------------------------*/

void Toggle_E()
{
	E = ~E;    // invert E
	Xms_Delay(1);  // 1ms delay 
	E = ~E;    // invert E again, so it returns to the value it held when entering the function. 
}

/*--------------------------------------------------------------------------------------------------------------------
Function:  Timer2_Init
Description:  Initialise timer 2 ports and registers. Timer 2 is used to create sound, the reload values vary depending on the type (square/sine) or pitch of the note played.
--------------------------------------------------------------------------------------------------------------------*/
void Timer2_Init()
{
	SFRPAGE = TMR2_PAGE;  //set the SFR page to Timer 2 page
	TMR2CN = 0x04;  //enable the timer
	TMR2CF = 0x08;  //select SYSCLK as timer clock source
	RCAP2L = cache_low;
	RCAP2H = cache_high;  //these reload values are specified in the main method and corresponds with the pitch of one of the seven notes. 
}
/*--------------------------------------------------------------------------------------------------------------------
Function:  Timer3_Init
Description:  Initialise timer 3 ports and registers. Timer3 overflows every 1ms, and is used for the LCD initialisation.
--------------------------------------------------------------------------------------------------------------------*/
void Timer3_Init()
{
	SFRPAGE = TMR3_PAGE;  //set the SFR page to Timer 3 page
	TMR3CN = 0x04;  //enable the timer
	TMR3CF = 0x0A;  //select SYSCLK as timer clock source
	RCAP3L = 0x05;
	RCAP3H = 0xFA;  //these reload values ensure a 1ms overflow for the timer. 
}

/*--------------------------------------------------------------------------------------------------------------------
Function:  Timer4_Init
Description:  Initialise timer 4 ports and registers Timer4 overflows every 500ms, and is used for the LED flashing in the volume state, and for the demo song.
--------------------------------------------------------------------------------------------------------------------*/
void Timer4_Init()
{
	SFRPAGE = TMR4_PAGE;  //set the SFR page to Timer 4 page
	TMR4CN = 0x04;  //enable the timer
	TMR4CF = 0x02;  //Set the timer output enable bit
	RCAP4L = 0xC6;
	RCAP4H = 0x06;  //these reload values ensure a 500ms overflow for the timer. 
}

/*--------------------------------------------------------------------------------------------------------------------
Function:  Voltage_Reference_Init
Description:  Initialise voltage references
--------------------------------------------------------------------------------------------------------------------*/
void Voltage_Reference_Init()
{
	SFRPAGE = ADC0_PAGE; //set the SRF Page to the ADC0 page
	REF0CN = 0x03; // Turn on internal bandgap reference and output buffer to get 2.4V reference
}
/*--------------------------------------------------------------------------------------------------------------------
Function:  DAC_Init
Description:  Initialise DAC0.
--------------------------------------------------------------------------------------------------------------------*/
void DAC_Init()
{
	SFRPAGE = DAC0_PAGE; //set the SRF Page to the DAC0 page
	DAC0CN = 0x98; //Set DAC output to update on Timer 2 overflow and enable DAC
}
/*--------------------------------------------------------------------------------------------------------------------
Function:  DAC_Init
Description:  Turns off the DAC. DAC is turned off whenever there is no keys pressed.
--------------------------------------------------------------------------------------------------------------------*/
void DAC_Deinit()
{
	SFRPAGE = DAC0_PAGE;  //set the SRF Page to the DAC0 page
	DAC0CN = 0x00; //Disable DAC
}
/*--------------------------------------------------------------------------------------------------------------------
Function:  Interrupts_Init
Description:  Initialise interrupts 5, 14 and 16
--------------------------------------------------------------------------------------------------------------------*/
void Interrupts_Init()
{
	IE = 0xA0; // Global enable interrupt + timer 2,3,4 interrupt
	EIE2 = 0x05; //set enable flag of Timer 3,4
}

/*--------------------------------------------------------------------------------------------------------------------
Function:  Timer2_ISR
Description:  Sends the relevant values to the DAC0 to create sound and generate a square/sine wave output. Selects a square or sine wave depending on the wave_bit.
--------------------------------------------------------------------------------------------------------------------*/
void Timer2_ISR(void) interrupt 5
{
	SFRPAGE_SAVE = SFRPAGE;  // Save Current SFR page
	SFRPAGE = DAC0_PAGE; //set the SFR page to the DAC0 page
	if (wave_bit == 0) { //if wave bit equals 0 and square wave mode is selected
		Sound_bit = ~Sound_bit; //toggles the sound bit, represents when the square wave will be high or low
		if (Sound_bit == 0) //if the sound bit == 0
		{
			DAC0 = 0; //the value sent to the dac is zero, when the square wave is low
		}
		else //if the sound bit = 1
		{
			DAC0 = volume[volume_level]; //the value sent to the dac is the volume level chosen to get the square wave high
		}
	}
	else { //if the wave bit equals 1 and sine wave mode is selected
		if (sine_position == 32) //if the position in the array is 32 and the end of the array has been reached
		{
			sine_position = 0; //re-initialise the array position to zero to go to the start of the array
		}
		DAC0 = sine_wave[sine_position]; //send the value at the sine_position in the array to the dac
		sine_position = sine_position + 1; //update the array position by adding 1 to it
	}
	TF2 = 0;  // Reset Interrupt by setting that timer 2 flag to 0
	SFRPAGE = SFRPAGE_SAVE;  // Restore SFR page
}
/*--------------------------------------------------------------------------------------------------------------------
Function:  Timer3_ISR
Description:  Timer 3 interrupt service routine used for the LCD initialisation. Timer 3 will overflow every 1ms, triggering a flag (LCD_delay) which will be used to update the initialisation.
--------------------------------------------------------------------------------------------------------------------*/
void Timer3_ISR(void) interrupt 14
{
	LCD_delay = 1;

	TF3 = 0;  // Reset Interrupt
}
/*--------------------------------------------------------------------------------------------------------------------
Function:  Timer4_ISR
Description:  Timer 4 interrupt service routine used for 1Hz flashing LED1 in volume control state and to play the demo song
--------------------------------------------------------------------------------------------------------------------*/
void Timer4_ISR(void) interrupt 16
{
	if (i == 2)
	{
		LD1 = ~LD1; //toggle LED 1
		i = 0; //reset i to 0
	}
	i++; //increment i by 1
	endsong = 1;
	TF4 = 0;  // Reset Interrupt
}

